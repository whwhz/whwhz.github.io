{"meta":{"title":"Whwhz","subtitle":null,"description":"光孕众生，众生随影。光涤吾魂，影庇吾体。","author":"zwh","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-02-12T14:14:36.000Z","updated":"2021-01-07T03:32:10.781Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"姑的小屋 与&nbsp; cungduafa&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"留言板","date":"2020-04-21T12:17:58.000Z","updated":"2021-01-07T03:33:19.065Z","comments":true,"path":"conmment/index.html","permalink":"http://example.com/conmment/index.html","excerpt":"","text":"有什么想说的? 有什么想问的?"},{"title":"分类","date":"2020-04-20T16:00:00.000Z","updated":"2021-01-07T03:31:41.535Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2020-02-13T15:13:05.000Z","updated":"2021-01-07T03:36:12.888Z","comments":false,"path":"donate/index.html","permalink":"http://example.com/donate/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-13T12:24:16.000Z","updated":"2021-01-07T03:31:54.960Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue3-Next!","slug":"Vue3-Next","date":"2021-01-29T03:31:02.000Z","updated":"2021-02-03T08:14:14.450Z","comments":true,"path":"post/27561.html","link":"","permalink":"http://example.com/post/27561.html","excerpt":"","text":"新特性 Performance (比 vue2 runtime 快了 2 倍) Tree shaking (按需编译代码) Ts support (更优秀的 Ts 支持) Composition API (组合 API) Custom Renderer API (自定义渲染器) 内置新特性组件 性能 Performance Tree shaking从官方给出的运行时编译视图中可以看到, 在 vue3 对模板解析为 vNode 的过程中, 在 render 函数对每个元素添加了不同状态的静态标记, 以此在生成 Virtual Dom 时而通过这些标记 flag 来判断减少不必要的 diff 而提升性能 diff 优化 // dom &lt;div id=\"app\"&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;world&lt;/p&gt; &lt;div :id=\"id\" style=\"color: red\"&gt;{{ msg }}&lt;/div&gt; &lt;/div&gt; // vue2 render function render() { with(this) { return _c('div', { attrs: { \"id\": \"app\" } }, [_c('h1', [_v(\"hello\")]), _c('p', [_v(\"world\")]), _c('div', { staticStyle: { \"color\": \"red\" }, attrs: { \"id\": id } }, [_v(_s(msg))])]) } } // vue3 render import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from \"vue\" export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createBlock(\"div\", { id: \"app\" }, [ _createVNode(\"h1\", null, \"hello\"), _createVNode(\"p\", null, \"world\"), _createVNode(\"div\", { id: _ctx.id, style: {\"color\":\"red\"} }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [\"id\"]) ])) } hoistStatic 静态提升vue3 中对于不参与更新的元素, 会进行静态提升, 只会被创建一次, 在后续渲染时直接进行复用(vue2 中每次都需重新创建) // dom &lt;div id=\"app\"&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;/div&gt; // 没有 hoistStatic export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createBlock(\"div\", { id: \"app\" }, [ _createVNode(\"p\", null, \"p1\"), _createVNode(\"p\", null, \"p2\"), _createVNode(\"p\", null, _toDisplayString(_ctx.msg), 1 /* TEXT */) ])) } // 进行 hoistStatic render const _hoisted_1 = { id: \"app\" } const _hoisted_2 = /*#__PURE__*/_createVNode(\"p\", null, \"p1\", -1 /* HOISTED */) const _hoisted_3 = /*#__PURE__*/_createVNode(\"p\", null, \"p2\", -1 /* HOISTED */) export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createBlock(\"div\", _hoisted_1, [ _hoisted_2, _hoisted_3, _createVNode(\"p\", null, _toDisplayString(_ctx.msg), 1 /* TEXT */) ])) } // Check the console for the AST 由此可见, render 中根据当前所用到的功能进行导入模块/函数, 并对动态属性进行标记, 以便于之后的遍历和更新, 会在 diff 时过滤掉不需要对比的静态元素 cacheHandlers 事件监听缓存对于绑定的同一个事件, 会把事件元素标记为动态属性而进行 diff, 进行 cacheHandlers 之后事件元素会进行缓存在更新时直接获取 // dom &lt;div id=\"app\"&gt; &lt;button @click=\"handleClick\"&gt;click&lt;/button&gt; &lt;/div&gt; // cacheHandlers 前 export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createBlock(\"div\", { id: \"app\" }, [ _createVNode(\"button\", { onClick: _ctx.handleClick }, \"click\", 8 /* PROPS */, [\"onClick\"]) ])) } // cacheHandlers 开启之后 export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createBlock(\"div\", { id: \"app\" }, [ _createVNode(\"button\", { onClick: _cache[1] || (_cache[1] = (...args) =&gt; (_ctx.handleClick &amp;&amp; _ctx.handleClick(...args))) }, \"click\") ])) } 在 vue3 的 diff 算法中, 只有进行过静态标记的才会进行比较追踪 Fragment 解释为不在限于模板中的单个根节点 &lt;template&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;/template&gt; Composition API相较于 vue2 基于原型的设计把钩子函数和核心方法挂载到实例上不同, vue3 则是把核心方法分离到一个个函数中进行组合使用, 可根据需要只使用部分函数, 而不在有过多的 this 绑定减少冗余 import { computed, reactive, onMounted } from 'vue' function useInit() { const state = reactive({ page_num: 1, page_size: 10 total: 10 }) function ready() { onMounted(() => { console.log('mounted') }) } const userInfo = computed(() => store.state.userInfo ) return { state, ready, userInfo } } setup() { const { state, ready, userInfo } = useInit() } 没有引用的方法, 则会被 tree-shaking 优化掉, 打包时也不会打包到最终代码里, 因此文件总量会相较于之前小很多可以利用混入的思想, 对模块进行分解细化处理来更好的实现模块化, 避免了 v2 中上下逻辑编写来回切换的问题 内置函数/钩子 setup()beforeCreate -&gt; setup -&gt; created 的一个执行时机setup 函数中, this 无法使用setup 函数只能为同步, 无法添加 async 修饰 ref接收一个简单类型的变量, 返回一个 proxy 对象,并监听其修改 相当于 data()中的定义的数据在 vue 中可以直接使用, js 中需要 ref.value 来使用 const n = ref(11); // ref 本质还是 reactive 上面还等于 const n = reactive({ value: 11 }); return { // 导出之后的数据才能在视图中使用 n, }; vue2.x 用来接收元素实例的 ref 也可以进行接收 &lt;div ref=\"dom\">获取DOM元素&lt;/div> onMounted(() => { const dom = ref(null); // div }) // 也可以通过函数的形式进行定义 &lt;div :ref=\"setRef\">获取DOM元素&lt;/div> const setRef = el => { myRef = el; } return { setRef } reactive跟 ref 作用类似, 把参数响应式的处理, 接收参数为一个对象 const state = reactive({ num: 0, }); function add() { state.num++; } return { // state 经过toRefs返回外面可以直接使用, 否则需要state.xxx来调用 ...toRefs(state), }; toRef toRefs生成响应式数据如果使用 ref 将某一个对象中的属性变成响应式的数据, 修改响应式数据是不会影响到原始的数据toRef 会影响到原始数据, 如果响应式的数据是通过 toRef 创建的, 修改则不会触发 ui 更新适用于各种性能优化的场景 let obj = { name: 'hello' } let name = toRef(obj, 'name') function handle() { name.value = 'world' // 此时obj和name都发生了修改 但是ui不会更新 } // toRefs 不需要指定key值 会将整个对象进行操作 let state = toRefs(obj) function handle() { state.name.value = 'world' } readonly shallowReadonlyreadonly 用于创建只读对象, 并且是递归只读shallowReadonly 用于创建非递归只读对象, 只是第一层数据只读与 const 只读不同于 const 不能给变量重新赋值, readonly 是属性保护, 不能给属性重新赋值 shallowReactive shallowRef triggerRef创建非递归数据进行监听, 控制递归的程度, 适用用于在数据量比较大 层级较深的场景如果是通过 shallowRef 创建的数据, vue 监听的是.value 的变化而不是第一层的变化triggerRef 根据传入的数据, 主动的更新界面, 如果是 reactive 类型数据, 无法主动进行更新 isRef isReactive isReadonly返回对象是否属于响应式对象和类型 toRaw markRawtoRaw 返回代理对象的原始对象markRaw 传入不需要被追踪的对象 let obj = { name: \"hello\" }; let state = reactive(obj); // Proxy&nbsp;{name: \"hello\"} let obj2 = toRaw(state); // {name: \"hello\"} obj === state // false obj === obj2 // true // 如果使用ref let obj3 = ref(hello) let obj4 = toRaw(obj3.value) ref/reactive 每次修改都会被追踪/更新 ui 界面, 有大量修改是很消耗性能的, 如果有一些操作不需要修改 ui, 则可以使用 toRaw 方法获取原始数据在进行修改就不会被追踪节省性能 customRef返回一个 ref 对象, 可以显式的控制依赖追踪和触发响应 function myRef(value) { return customRef((track, trigger) => { // customRef 可以用来异步操作, 但是在get中调用 trigger, 会导致内存泄漏 return { get() { track(); // 表明这个数据是需要追踪变化的 return value; }, set(newValue) { value = newValue; trigger(); // 更新数据 }, }; }); } setup() { const name = myRef('hello') const handle = () => { name.value = 'world' } return { name, handle } } 生命周期 2.x与 3.0的对照 beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 3.0 中钩子函数都被分离了出来, 可以在外部直接定义完再到 setup 中进行使用, 以达到混入的效果 function baseMixins() { const n1 = ref(1); const addN1 = () => { n1.value++; }; onMounted(() => { console.log(\"baseMixins mounted\"); }); return { n1, addN1, }; } setup() { baseMixins() setup() { return { ...baseMixins() } } } getCurrentInstance 获取当前实例3.0 中摒弃了传统 this 来调用实例对象, 提供了 getCurrentInstance 来获取当前组件实例, 可以通过 ctx 来获取上下文对象 const { ctx } = getCurrentInstance(); // ctx.$router / ctx.$props ctx.$parent 等 // 路由拦截 ctx.$router.beforeEach((to, from, next) => { console.log(\"路由的生命周期\"); next(); }); 新观察者 watch 和计算属性 computed watchEffect watch( () => n1.value, (newVal, oldVal) => { console.log(\"新值\", newVal); console.log(\"老值\", oldVal); } ); // 如果是同时监听多个数据, 接收的参数可以为一个数组 watch( [() => n1.value, () => n2.value], ([n1Val, n2Val], [n1OldVal, n2OldVal]) => { // 对应关系是相同的 console.log(\"n1: \", n1Val, n1OldVal); console.log(\"n2: \", n2Val, n2OldVal); } ); computed 相较于之前只是写法上的变化 const price = ref(10); const priceFormat = computed(() => \"¥\" + price.value); watchEffect 传入一个立即执行函数, 并追踪其依赖, 在其依赖更新时重新运行该函数, 而且函数会在当前组件生命周期结束时自动卸载 const n3 = ref(1); const n3Change = () => { n3.value++; }; const n3Watch = watchEffect(() => { if (n3.value) { console.log(\"n3 change\", n3.value); } }); return { n3, n3Change, };","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"H5与原生App交互JSBridge","slug":"H5与原生APP交互JSBridge","date":"2021-01-27T08:52:22.000Z","updated":"2021-01-28T02:47:14.797Z","comments":true,"path":"post/9238.html","link":"","permalink":"http://example.com/post/9238.html","excerpt":"","text":"在 App 嵌套 H5 项目需要数据通信, 因此借助原生 WebViewJavascriptBridge 进行交互1. IOSios 需要借助iframe进行连接, 需要先进行一个注册 function setupWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); } if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); } window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(\"iframe\"); WVJBIframe.style.display = \"none\"; WVJBIframe.src = \"https://__bridge_loaded__\"; document.documentElement.appendChild(WVJBIframe); setTimeout(function () { document.documentElement.removeChild(WVJBIframe); }, 0); } 注册没问题就能直接进行交互了, 交互上分客户端调用 H5, 和 H5 调用客户端 // 使用 setupWebViewJavascriptBridge(function (bridge) { // 注册一个方法 funcName 客户端进行调用, responseCallback为回调函数 bridge.registerHandler(\"funcName\", function (data, responseCallback) { console.log(\"ios registerHandler:ok\", data); responseCallback(data); }); // js调用客户端的方法 此时的funcName为客户端已经配置好的方法 var params = { key: \"value\" }; // 可以发送JSON数据给到客户端 bridge.callHandler( \"funcName\", params, function responseCallback(responseData) { // 在回调里面拿到客户端返回的数据 console.log(\"ios response:\", responseData); } ); }); 需要注意的是在项目中注册的方法需要是全局方法不能是内部/私有方法, vue项目中如果要使用methods中的方法还需要额外挂载到window Android同样先用函数进行判断是否可用 进行注册 function connectWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { callback(WebViewJavascriptBridge); } else { document.addEventListener( \"WebViewJavascriptBridgeReady\", function () { callback(WebViewJavascriptBridge); }, false ); } } 有了注册函数之后吗就能直接调用上面的函数进行交互 connectWebViewJavascriptBridge(function (bridge) { // 注册一个方法 funcName 客户端进行调用, responseCallback为回调函数 bridge.registerHandler(\"funcName\", function (data, responseCallback) { console.log(\"ios registerHandler:ok\", data); responseCallback(data); }); // 调用客户端funcName方法, 可用传JSON给到客户端和获取返回的数据 bridge.callHandler( \"funcName\", { key: \"value\" }, function responseCallback(responseData) { console.log(\"Android response:\", responseData); } ); }); 除了原生的 WebViewJavascriptBridge 交互方法外, 还有一些直接封装好的库可以使用, 使用方法更为简单便捷, 这里推荐 DSBridge DSBridge-IOS: https://github.com/wendux/DSBridge-IOSDSBridge-Android: https://github.com/wendux/DSBridge-Android 初始化 dsBridge npm install dsbridge // 初始化一个为对象 const dsBridge = require(\"dsbridge\") 调用客户端方法 / 注册全局方法给客户端调取 // 同步调用 var result = dsBridge.call(\"funcName\", params); // 异步调用 dsBridge.call(\"funcName\", params, function (response) { console.log(\"response\"); }); // 注册一个方法 dsBridge.register(\"jsApi\", function (...args) { console.log(\"jsApi res:ok\", ...args); }); // 注册一个对象，指定一个命名空间 dsBridge.register(\"test\", { tag: \"test\", test1: function () { return this.tag + \"1\"; }, test2: function () { return this.tag + \"2\"; }, }); //检测是否存在一个名为'testAsyn'的API(无论同步还是异步) dsBridge.hasNativeMethod(\"testAsyn\"); //检测test命名空间下是否存在一个’testAsyn’的API dsBridge.hasNativeMethod(\"test.testAsyn\"); // 检测是否存在一个名为\"testSyn\"的异步API dsBridge.hasNativeMethod(\"testSyn\", \"asyn\"); //false","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"App","slug":"App","permalink":"http://example.com/tags/App/"}]},{"title":"ES2017 ~ ES2020新特性","slug":"ES2016-ES2020新特性","date":"2021-01-18T01:56:53.000Z","updated":"2021-01-26T07:08:15.606Z","comments":true,"path":"post/58832.html","link":"","permalink":"http://example.com/post/58832.html","excerpt":"","text":"本文总结了一些 ES7 之后的新语法, 内容大多抄录于网络包含检测 Array/String.prototype.includes()判断字符串/数组是否包含指定元素, 第二个参数为检索起始位置, 返回值为 true/false Array.prototype.includes(searchElement, fromIndex) 幂运算符号 ** x:Number ** y:Number 相当于 Math.pow(x, y) 字符串补充 String.prototype.padStart() / padEnd() / trimStart() / trimEnd() / replaceAll()padStart/padEnd用于填充字符串直到指定长度，两个参数，第一个参数为目标长度，第二个字符串为用于填充的字符串 let str = '123456789' let res = str.padStart(14, '456') // 在开始填充 let res2 = str.padEnd(14, '456') // 在结束填充 console.log(res) // 45645123456789 console.log(res2) // 12345678945645 trimStart()/trimEnd() 相当于 String.prototype.trim()的细分使用 const string = ' Hello World! '; string.trimStart(); // 'Hello World! ' string.trimEnd(); // ' Hello World!' replaceAll() 方法是基于 replace(/\\!/g, '') 方法的延伸 const string = '😃!😯!😛'; console.log(string.replaceAll('!', '👿')) // 😃👿😯👿😛 对象扩展 Object.keys() / values() / entries() / fromEntries() // 处理对象 返回值：一个对象的所有可枚举属性的键的数组 let person = {name:\"张三\",age:99,address:\"北京\",getName:function(){}}; console.log(Object.keys(person)); // [\"name\", \"age\", \"address\", \"getName\"] // 处理数组 返回值：数组的索引值数组 let arr = [1,2,3,4,5,6]; console.log(Object.keys(arr)); //[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"] // 处理字符串 返回值：数组的索引值数组 let str = \"Hello,world\"; console.log(Object.keys(str)); //[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] // 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值, 参数不是对象，Object.values会先将其转为对象 let obj = { name: 'Cc', age: '99', job: 'web' } console.log(Object.values(obj)) [\"Cc\", \"99\", \"web\"] // 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组 let obj = { name: 'Cc', age: '99', job: 'web' } console.log(Object.entries(obj)) // [[\"name\", \"Cc\"][\"age\", \"99\"][\"job\", \"web\"]] // 方法返回一个对象，成员是Object.entries的键值对数组 let entries = [[\"name\", \"Cc\"]]; console.log(Object.fromEntries(entries)); // {name: \"Cc\"} 异步迭代 Async For// 在for循环中支持async/await修饰 来循环存在异步的队列 function getPromise (time) { return new Promise((resovle) => { setTimeout(() => { resovle(time) }, time) }) } const arr = [getPromise(1000), getPromise(2000), getPromise(3000)]; let main = async () => { for await (let item of arr) { console.log(item) // 1000 2000 3000 } } // 不使用async/await的话for循环会返回三个Promise对象 Promise.race / anyPromise.race 则是返回最先成功的实例 let p1 = new Promise((resolve, reject) => { setTimeout(() => { resolve('p1p1') },1000) }) let p2 = new Promise((resolve, reject) => { setTimeout(() => { reject('p2p2') }, 500) }) Promise.race([p1, p2]).then((result) => { console.log(result) // p1p1 }).catch((error) => { console.log(error) }) Promise.any 返回给定实例只要有一例成功 则返回第一条实例作为返回值, 与Promise.race不同, 它会在所有实例失败之后才返回失败的值 let p3 = new Promise((resolve, reject) => { setTimeout(() => { resolve('p3p3') },1000) }) let p4 = new Promise((resolve, reject) => { setTimeout(() => { reject('p4p4') }, 500) }) let p5 = new Promise((resolve, reject) => { setTimeout(() => { reject('p5p5') }, 500) }) try { const first = await Promise.any([p3, p4, p5]); console.log('first',first) // first p3p3 } catch (error) { console.log('error',error) } 数组扁平展开 Array.prototype.flat() / Array.prototype.flatMap() // flat() 通过传入层级 默认为1 来展开多维数组 [1, 2, [3, 4]].flat(); // [ 1, 2, 3, 4 ] [1, 2, [3, 4, [5, 6]]].flat(2); // [ 1, 2, 3, 4, 5, 6 ] 空值合并运算符 ‘??’ 空值合并运算符 ?? 提供了一种简短的语法，用来获取列表中第一个“已定义”的变量 a ?? b 的结果是： a，如果 a 不是 null 或 undefined， b，其他情况 所以，value = a ?? b 是下面这个表达式的简写：如果a是已定义的则返回a的值 value = (a !== null &amp;&amp; a !== undefined) ? a : b; 区别于 || 返回第一个 真 值。 ?? 返回第一个 已定义的值。 逻辑赋值运算符 / 数字分隔符逻辑赋值运算符结合了 逻辑运算符 和 赋值表达式。逻辑赋值运算符有两种：或等于（||=）, 且等于（&amp;&amp;=） a ||= b 等同于 a || (a = b); a &amp;&amp;= b 等同于 a &amp;&amp; (a = b); 数字分隔符将数字进行分组, 提高可读性 1_000_000_000 // 1000000000 1e10_000 // Infinity 123_4.56 // 1234.56","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Nuxt框架使用踩坑","slug":"Nuxt框架使用的一些问题","date":"2021-01-13T09:33:06.000Z","updated":"2021-02-03T03:04:34.964Z","comments":true,"path":"post/61197.html","link":"","permalink":"http://example.com/post/61197.html","excerpt":"","text":"本文记录 Vue 项目中使用 Nuxtjs 框架进行 SSR 渲染中遇到的一些问题 NuxtJs: https://www.nuxtjs.cn/guide/installationEnv: node^14.15.4 &nbsp; npm^6.14.10 &nbsp; nuxt^2.14.6 &nbsp; vue^2.6.12 路由嵌套在自动路由中, 要处理嵌套路由需要注意文件位置和文件夹的命名, 文档中也很清楚 根据图示配置二级路由没有问题, 但项目中有这二级菜单嵌套路由的场景, 根据文档中来配置只能同时显示最后一级路由的内容,达不到菜单切换的目的 可以看到, 父 page 并没有一起渲染出来 此时把文件结构修改一下, 可以很方便的达到效果 😈 -| pages/ -| pages/ --| static/ --| static.vue ---| index.vue &gt; &gt; &gt; --| static/ ---| main.vue ---| main.vue 插件使用由于配置开启了 ssr 模式, 所以在直接引入使用一些操作 dom 元素的插件时, 会有 error: window/document is not defined 等等报错, 其实这种问题是由于服务端渲染时不存在 window 对象导致可以在 nuxt.config / plugins引入时设置设置 ssr: false 来解决 但是在我项目中还使用到了 JSEncrypt 这个库来进行数据加密, 上面方法起不到作用,借鉴网络上的方法例如引入前定义 global.window/document/navigator等, 还会有其他意想不到的问题 -_-||, 这些问题都是 Nuxt 的特性导致, 我是采用在加密函数头部进行环境判断来简单应付了一下, 竟然不报错了 😅 (好像还可以通过 node 的 jsdom 来处理) 同样在使用需要操作 DOM 元素的插件时, 不想要全局引入也可以通过先判断在引入的形式, 这里使用到了二维码插件 qrcode 请求代理/全局样式 在 Nuxt 中想要使用请求代理需要先安装 @nuxtjs/axios || @nuxtjs/proxy 之后再 nuxt.config / modules 进行引入然后配置, 之后的 proxy 就跟 vue 项目中的一样了全局 css 同理, 先引入@nuxtjs/style-resources 之后在 styleResources中引入文件即可, 如果引入 css 预处理器要先进行相应 loader 的安装 不同环境配置 Nuxt 本身提供了配置项在 nuxt.config / env 可供配置 env: { BASE_URL: process.env.BASE_URL, NODE_ENV: process.env.NODE_ENV }还可以在打包时借助打包命令设置环境变量 注: 在非 Mac 系统下 直接设置 NODE_ENV 会报错, 需要借助cross-env来进行 此时已经可以根据环境变量来设置不同的请求地址了 url 转义在使用 vue-router 编程式路由时, 在 nuxt 中推荐使用params进行传参处理, 如果使用到 query 进行多个参数查询时, 如果不进行转义在刷新页面/重定向页面时会出现识别不了的情况如下图此时的 url 为: /check-result?contract_no=440376&amp;type=result&amp;form=contract&amp;state=3 因为在服务器渲染的的机制, url 参数中存在 = 等符号时服务器端可能无法获得正确的参数值, 并且直接重定向到错误页面, 所以需要对 url 参数转义处理, 以下为处理的函数, 可以直接挂在到vue 原型之上便于全局使用 /** * @param {Array} actual * @returns {Array} */ export function cleanArray(actual) { const newArray = []; for (let i = 0; i &lt; actual.length; i++) { if (actual[i]) { newArray.push(actual[i]); } } return newArray; } /** * @param {Object} json 对url参数进行编码 * @returns {Array} */ export function param(json) { if (!json) return \"\"; return cleanArray( Object.keys(json).map(key =&gt; { if (json[key] === undefined) return \"\"; return encodeURIComponent(`${key}=${json[key]}`); }) ).join(\"&amp;\"); } /** * @param {string} url 解析获取url参数 * @returns {Object} */ export function param2Obj(url) { url = url || location.href; const search = url.split(\"?\")[1]; if (!search) { return {}; } return JSON.parse( '{\"' + decodeURIComponent(search) .replace(/\"/g, '\\\\\"') .replace(/&amp;/g, '\",\"') .replace(/=/g, '\":\"') .replace(/\\+/g, \" \") + '\"}' ); } 使用上传值就直接替代 $router.push 中的 query, 获取则使用 param2Obj 替换 $route.query 即可 // 路由查询跳转 $router.push({ path: `./check-result?${$param({ contract_no: record.contract_no, type: 'result', form: 'contract', state: record.contract_state, audit_note: record.audit_note, })}`, }) // 查询参数获取 const { contract_no, state, audit_note, form, type } = this.$param2Obj(); 服务器部署 第一次部署服务器需要先在服务器验证 node 环境是否可用,如果没有 node 环境, 可以使用 yum 命令来安装, 不过这种形式一般版本较低, 所有尽量直接用压缩包的形式解压tar -xvf node-v14.15.4-linux-x64.tar安装 解压之将 node/bin (这里的 node 指解压之后的文件夹简写) 下面的 node / npm 两个命令设置为全局命令, 可以通过 ln -s /opt/sxsmk_web/node/bin/node /usr/local/bin/node ln -s /opt/sxsmk_web/node/bin/npm /usr/local/bin/npm 此时可以通过 node -v 来验证是否成功, 当然也可以直接在 etc/profile 文件中写入环境变量来配置 环境配置之后, 将 Nuxt 打包生成的文件 Nuxt.config.js / package.json / .nuxt / static 等文件/文件夹 上传至服务器并安装依赖 利用 pm2 (node 的进程管理器) 来启动项目即可, 以下为 pm2 常用命令 pm2 start npm --watch --name \"webssr\" -- run start // 启动并监控一个进程 pm2 list // 查看全部进程 pm2 info 0 // 查看一个进程的具体信息 后面是进程id pm2 stop/restart/reload/delete 0/all // 停止/开启/重载/删除 某个/全部进程 pm2 logs [--raw] // 查看日志","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"那些好用的工具函数整理","slug":"业务中好用的工具函数整理","date":"2021-01-08T01:15:46.000Z","updated":"2021-02-03T08:41:53.887Z","comments":true,"path":"post/20333.html","link":"","permalink":"http://example.com/post/20333.html","excerpt":"","text":"总结自己一些日常使用的过的工具函数, 目前分为数据处理类, 时间处理类, 对象类, 验证函数类和浏览器功能类等, 持续更新对象类/** * @param {Object} * @returns {JSON} */ const stringify = (() => { const replacer = (key, val) => { if(typeof val === 'symbol') { return val.toString(); } if(val instanceof Set) { return Array.from(val); } if(val instanceof Map) { return Array.from(val.entries()); } if(typeof val === 'function') { return val.toString(); } return val; } return (obj, spaces = 0) => JSON.stringify(obj, replacer, spaces) })(); /** * @param {Object|Array} 用于检测对象或数组是否为空 * @returns {Boolean} */ export function isEmpty(x) { if(Array.isArray(x) || typeof x === 'string' || x instanceof String ) { return x.length === 0; } if(x instanceof Map || x instanceof Set) { return x.size === 0; } if(({}).toString.call(x) === '[object Object]') { return Object.keys(x).length === 0; } return false; } /** * @param {Object} 一般JSON.parse(JSON.stringify(obj))不能满足就用得到 * @returns {Object} */ export function deepClone(source) { if (!source && typeof source !== 'object') { throw new Error('error arguments', 'deepClone') } const targetObj = source.constructor === Array ? [] : {} Object.keys(source).forEach(keys => { if (source[keys] && typeof source[keys] === 'object') { targetObj[keys] = deepClone(source[keys]) } else { targetObj[keys] = source[keys] } }) return targetObj } /** * @param {Object} target * @param {(Object|Array)} 第二个参数可以是包含多个对象的数组 * @returns {Object} */ export function objectMerge(target, source) { if (typeof target !== 'object') { target = {} } if (Array.isArray(source)) { return source.slice() } Object.keys(source).forEach(property => { const sourceProperty = source[property] if (typeof sourceProperty === 'object') { target[property] = objectMerge(target[property], sourceProperty) } else { target[property] = sourceProperty } }) return target } 时间类/** * Parse the time to string * @param {(Object|string|number)} time * @param {string} cFormat * @returns {string | null} */ export function parseTime(time, cFormat) { if (arguments.length === 0) { return null } const format = cFormat || '{y}-{m}-{d} {h}:{i}:{s}' let date if (typeof time === 'object') { date = time } else { if ((typeof time === 'string') && (/^[0-9]+$/.test(time))) { time = parseInt(time) } if ((typeof time === 'number') && (time.toString().length === 10)) { time = time * 1000 } date = new Date(time) } const formatObj = { y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() } const time_str = format.replace(/{([ymdhisa])+}/g, (result, key) => { const value = formatObj[key] // Note: getDay() returns 0 on Sunday if (key === 'a') { return ['日', '一', '二', '三', '四', '五', '六'][value ] } return value.toString().padStart(2, '0') }) return time_str } /** * @param {number} time * @param {string} option 需要结合上面的函数一起使用 * @returns {string} */ export function formatTime(time, option) { if (('' + time).length === 10) { time = parseInt(time) * 1000 } else { time = +time } const d = new Date(time) const now = Date.now() const diff = (now - d) / 1000 if (diff < 30) { return '刚刚' } else if (diff < 3600) { // less 1 hour return Math.ceil(diff / 60) + '分钟前' } else if (diff < 3600 * 24) { return Math.ceil(diff / 3600) + '小时前' } else if (diff < 3600 * 24 * 2) { return '1天前' } if (option) { return parseTime(time, option) } else { return ( d.getMonth() + 1 + '月' + d.getDate() + '日' + d.getHours() + '时' + d.getMinutes() + '分' ) } } 数据类/** * @param {Array|Object} list * @param {func} cb 回调函数 */ export function forEach(list, callback) { const entries = Object.entries(list); let i = 0; const len = entries.length; for(;i < len; i++) { const res = callback(entries[i][1], entries[i][0], list); if(res === true) break; } } export const isOfType = (() => { // create a plain object with no prototype const type = Object.create(null); // check for null type type.null = x => x === null; // check for undefined type type.undefined = x => x === undefined; // check for nil type. Either null or undefined type.nil = x => type.null(x) || type.undefined(x); // check for strings and string literal type. e.g: 's', \"s\", `str`, new String() type.string = x => !type.nil(x) && (typeof x === 'string' || x instanceof String); // check for number or number literal type. e.g: 12, 30.5, new Number() type.number = x => !type.nil(x) && (// NaN & Infinity have typeof \"number\" and this excludes that (!isNaN(x) && isFinite(x) && typeof x === 'number' ) || x instanceof Number); // check for boolean or boolean literal type. e.g: true, false, new Boolean() type.boolean = x => !type.nil(x) && (typeof x === 'boolean' || x instanceof Boolean); // check for array type type.array = x => !type.nil(x) && Array.isArray(x); // check for object or object literal type. e.g: {}, new Object(), Object.create(null) type.object = x => ({}).toString.call(x) === '[object Object]'; // check for provided type instance type.type = (x, X) => !type.nil(x) && x instanceof X; // check for set type type.set = x => type.type(x, Set); // check for map type type.map = x => type.type(x, Map); // check for date type type.date = x => type.type(x, Date); return type; })(); /** * @returns {string} */ export function createUniqueString() { const timestamp = +new Date() + '' const randomNum = parseInt((1 + Math.random()) * 65536) + '' return (+(randomNum + timestamp)).toString(32) } /** * @param {string} url * @returns {Object} */ export function getQueryObject(url) { url = url == null ? window.location.href : url const search = url.substring(url.lastIndexOf('?') + 1) const obj = {} const reg = /([^?&=]+)=([^?&=]*)/g search.replace(reg, (rs, $1, $2) => { const name = decodeURIComponent($1) let val = decodeURIComponent($2) val = String(val) obj[name] = val return rs }) return obj } 验证类/* * @param {String} 身份证号 * @returns {Boolean} */ export const certNoValidate = certNo => { if (certNo) { // 加权因子 const weight_factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]; // 校验码 const check_code = [\"1\", \"0\", \"X\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\"]; let code = certNo + \"\"; let last = certNo[17]; //最后一个 let seventeen = code.substring(0, 17); let arr = seventeen.split(\"\"); let len = arr.length; let num = 0; for (let i = 0; i < len; i++) { num = num + arr[i] * weight_factor[i]; } let resisue = num % 11; let last_no = check_code[resisue]; const newReg = /^[1-9][0-9]{5}([1][9][0-9]{2}|[2][0][0|1][0-9])([0][1-9]|[1][0|1|2])([0][1-9]|[1|2][0-9]|[3][0|1])[0-9]{3}([0-9]|[X])$/; let format = newReg.test(certNo); if (last_no && format) { return true; } else { return false; } } else { return false; } }; /* * @param {String} 只适合国内手机, 海外目前没接触 * @returns {Boolean} */ export const mobileValidate = mobile => { const newReg = /^1(3|4|5|6|7|8|9)\\d{9}$/; if (newReg.test(mobile)) { return true; } else { return false; } }; /* * @param {String} 至少6位的字母数字组合 * @returns {Boolean} */ export const pwdValidate = pwd => { const reg = /(?=.*?[a-zA-Z])(?=.*?[0-9])[a-zA-Z0-9]{6,}$/; if (reg.test(pwd)) { return true; } else { return false; } }; 浏览器类/* 相较于a标签直接下载可以附加参数, 可以用于权限控制中的请求下载 * @param {String} 文件url * @param {Object} 请求参数 * @returns Null */ export function downloadFile(downLoadurl, params = {}, method = \"get\") { // params = { ...params, token: store.getters.token }; const downloadForm = document.createElement(\"form\"); try { if (downloadForm) { // downloadForm.action = 'http://192.168.1.108:9001' + downLoadurl downloadForm.action = downLoadurl; downloadForm.method = method; for (const key in params) { if (!params[key]) continue; const input = document.createElement(\"input\"); input.type = \"hidden\"; input.name = key; input.value = params[key]; downloadForm.appendChild(input); } // downloadForm.headers = { // token: store.getters.token // }; document.body.appendChild(downloadForm); downloadForm.submit(); } } catch (e) { console.log(e); } finally { document.body.removeChild(downloadForm); } } /** * Add class to element * @param {HTMLElement} elm * @param {string} cls */ export function addClass(ele, cls) { if (!hasClass(ele, cls)) ele.className += ' ' + cls } /** * Remove class from element * @param {HTMLElement} elm * @param {string} cls */ export function removeClass(ele, cls) { if (hasClass(ele, cls)) { const reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)') ele.className = ele.className.replace(reg, ' ') } } /** * @param {HTMLElement} elm * @param {string} cls * @returns {boolean} */ export function hasClass(ele, cls) { return !!ele.className.match(new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)')) } /** * @param {HTMLElement} element * @param {string} className */ export function toggleClass(element, className) { if (!element || !className) { return } let classString = element.className const nameIndex = classString.indexOf(className) if (nameIndex === -1) { classString += '' + className } else { classString = classString.substr(0, nameIndex) + classString.substr(nameIndex + className.length) } element.className = classString } /* base64转file * @param {file} * @returns {base64} */ function dataURLtoFile(base64) { let arr = base64.split(\",\"), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new File([u8arr], { type: mime }); } /* base64转二进制 * @param {String} “data:image/png;base64,****”,逗号之前都是一些说明性的文字，我们只需要逗号之后的就行了 * @returns {blob} */ function dataToBlob(data, mime) { data = data.split(',')[1] data = window.atob(data) var ia = new Uint8Array(data.length) for (var i = 0; i < data.length; i++) { ia[i] = data.charCodeAt(i) } // canvas.toDataURL 返回的默认格式就是 image/png return new Blob([ia], { type: mime }) } /* 压缩图片 * @param {file} * @returns {base64} */ export function compressImg(file) { let src; let fileSize = parseFloat(parseInt(file[\"size\"]) / 1024 / 1024).toFixed(2); let read = new FileReader(); read.readAsDataURL(file); return new Promise(function(resolve, reject) { read.onload = function(e) { let img = new Image(); img.src = e.target.result; img.onload = function() { //默认按比例压缩 let w = this.width, h = this.height; //生成canvas let canvas = document.createElement(\"canvas\"); let ctx = canvas.getContext(\"2d\"); let base64; // 创建属性节点 canvas.setAttribute(\"width\", w); canvas.setAttribute(\"height\", h); ctx.drawImage(this, 0, 0, w, h); if (fileSize < 1) { //如果图片小于一兆 那么不执行压缩操作 base64 = canvas.toDataURL(file[\"type\"], 1); } else if (fileSize > 1 && fileSize < 2) { //如果图片大于1M并且小于2M 那么压缩0.5 base64 = canvas.toDataURL(file[\"type\"], 0.5); } else { //如果图片超过2m 那么压缩0.2 base64 = canvas.toDataURL(file[\"type\"], 0.2); } // 这里返回的是base64编码 如果想要文件格式还需要再次转换 resolve(base64); }; }; }); } WIDGET = { CONFIG: { \"modules\": \"0124\", \"background\": 1, \"tmpColor\": \"FFFFFF\", \"tmpSize\": 16, \"cityColor\": \"FFFFFF\", \"citySize\": 16, \"aqiSize\": 16, \"weatherIconSize\": 24, \"alertIconSize\": 18, \"padding\": \"10px 10px 10px 10px\", \"shadow\": \"1\", \"language\": \"auto\", \"borderRadius\": 5, \"fixed\": \"false\", \"vertical\": \"middle\", \"horizontal\": \"center\", \"key\": \"B1Dc3JIvYg\" } }","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-07T03:03:33.015Z","updated":"2021-01-07T03:28:22.540Z","comments":true,"path":"post/16107.html","link":"","permalink":"http://example.com/post/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment WIDGET = { CONFIG: { \"modules\": \"0124\", \"background\": 1, \"tmpColor\": \"FFFFFF\", \"tmpSize\": 16, \"cityColor\": \"FFFFFF\", \"citySize\": 16, \"aqiSize\": 16, \"weatherIconSize\": 24, \"alertIconSize\": 18, \"padding\": \"10px 10px 10px 10px\", \"shadow\": \"1\", \"language\": \"auto\", \"borderRadius\": 5, \"fixed\": \"false\", \"vertical\": \"middle\", \"horizontal\": \"center\", \"key\": \"B1Dc3JIvYg\" } }","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"App","slug":"App","permalink":"http://example.com/tags/App/"}]}